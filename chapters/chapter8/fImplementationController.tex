\section{Implementation of the Controller}\label{impController}
The designed controller being shown to be working in the simulation environment, the next step is to actually implement it in reality.

Since the controller calculations are to be implemented on the Beaglebone Black board, which is a computer and cannot run continuously, the controller has to go through a discretization. This means that an approximation of it is made in the discrete domain.

\subsection{Discretization of the Controller}\label{ssec:discnController}
The discretization process of a controller consists in using the map from the continuous domain to the discrete domain (z-domain), with respect to the sampling time, \si{T}, of the feedback control system\fxnote{Add reference}:
%
\begin{flalign} 
  &\si{s = j \omega \to z = e^{s T}}\label{exp:cont2Disc}&
\end{flalign}
%
Since the discrete domain cannot by definition represent the complete behavior of a system through time, approximations are used to estimate this behavior.

One of the most commonly used aproximations is the bilinear transform (or Tustin's method) which is based on the trapezoidal integration principle. A reason to use this method instead of others is that it maps the entire LHP (stable area in the continuous domain) into the unit circle (stable area in the discrete domain).\fxnote{Add reference (Franklin \& Powell)}\\
The bilinear approximation of \si{z} is defined as:
%
\begin{flalign} 
  &\si{z \approx \frac{1 + s \frac{T}{2}}{1 - s\frac{T}{2}}}\label{exp:bilinearTransform}&
\end{flalign}
%
The inverse transformation of \expr{exp:bilinearTransform} is given by:
%
\begin{flalign} 
  &\si{s \approx \frac{T}{2} \cdot \frac{1 - z^{-1}}{1 + z^{-1}}}\label{exp:inverseBilinearTransform}&
\end{flalign}
%
In general, the \expr{exp:inverseBilinearTransform} is used to replace \si{s} in the continuous-time transfer function of the designed controller. However, due to the non-linear mapping induced by the discretization, a pre-warp of the frequencies can be used. This avoids effects of phase lag near the cross-over frequency and thus, also avoids unwanted reduction of gain or phase margins, see \cite{GGu}\fxnote{add reference to Ove Andersen's lectures}. 

Moreover, Matlab has an available function, \lstinline{c2d()}, designed to convert a continuous system's transfer function into the discrete domain by specifying the sampling time and the desired method. The \lstinline{'prewarp'} option that is used, needs a supplementary argument corresponding to the critical fequency, chosen here to be \fxnote{Insert chosen critical frequency for the discretization}\si{rad \cdot s^{-1}}, see \fxnote{Add reference to Matlab documentation}.

Figref{fig:bodePrewarpVsNoPrewarpVsContinuous} shows a Bode plot comparing the original continuous controller's frequency and phase responses with the discretized controller's with both normal Tustin's method and pre-warping.
\fxnote{Insert correct figure}
%
\begin{figure}[H]
  \centering
  % \includegraphics[scale=.3]{figures/filename}
  \caption{Bode plot of the continuous controller (in xcolor), discretized controller (in ycolor) and pre-warped discretized controller (in zcolor)}
  \label{fig:bodePrewarpVsNoPrewarpVsContinuous}
\end{figure}  

From figref{fig:bodePrewarpVsNoPrewarpVsContinuous}, it is possible to see...

Thus, the pre-warped discretized controller is chosen for the actual implementation on the Cubli, in the code base, see \secref{se:codeBase}, and its discrete transfer function is:
\begin{flalign}
  \eq{J_m \cdot \dot{\omega}_m(t)} {\tau_m(t) - B_m \cdot \omega_m(t) - r_m \cdot f_c(t)}\unit{N \cdot m} 
  \label{MotorGearNewtonSecLaw}
\end{flalign}